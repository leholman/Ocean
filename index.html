<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ocean Wave Simulation</title>
  <style>
    :root{
      --bg0:#07131d;
      --bg1:#0a1e2d;
      --text:rgba(255,255,255,.88);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--text);
      background: radial-gradient(1200px 700px at 15% 10%, rgba(102,205,255,.12), transparent 55%),
                  radial-gradient(900px 600px at 85% 20%, rgba(60,170,255,.10), transparent 60%),
                  linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow:hidden;
    }
    canvas{position:fixed; inset:0; width:100%; height:100%}
    .label{
      position:fixed;
      left:18px;
      top:16px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 18px 50px rgba(0,0,0,.45);
      font-size:13px;
      letter-spacing:.2px;
      color: rgba(255,255,255,.72);
      user-select:none;
    }
    .label b{color:rgba(255,255,255,.92); font-weight:650}
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="label"><b>Ocean Wave Simulation</b> — top-down</div>

  <script>
    // Top-down ocean surface.
    // Performance strategy:
    // - Render into a small simulation buffer (ImageData) each frame.
    // - Two passes: (1) compute height field into a Float32Array, (2) shade from finite-difference normals.
    // - One putImageData + upscale (no per-cell fillRect).

    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

    // Fixed “middle” settings (no UI)
    const params = {
      wind: 0.5,
      height: 0.5,
      light: 0.5,
      paused: false
    };

    // Quality knob: lower = faster.
    const SIM_MAX = 360; // max sim dimension (pixels)

    const sim = document.createElement('canvas');
    const sctx = sim.getContext('2d', { alpha: false, desynchronized: true, willReadFrequently: true });

    let W=0,H=0,SW=0,SH=0;
    let img=null, pix=null, heights=null;

    function resize(){
      W = window.innerWidth;
      H = window.innerHeight;
      canvas.width = W;
      canvas.height = H;

      // Choose a small sim resolution, keeping aspect.
      const maxDim = Math.min(SIM_MAX, Math.max(220, Math.floor(Math.min(W,H) * 0.55)));
      if(W >= H){
        SH = maxDim;
        SW = Math.floor(maxDim * (W/H));
      } else {
        SW = maxDim;
        SH = Math.floor(maxDim * (H/W));
      }
      // Hard caps for ultrawide screens.
      SW = Math.min(SIM_MAX*2, Math.max(240, SW));
      SH = Math.min(SIM_MAX*2, Math.max(240, SH));

      sim.width = SW;
      sim.height = SH;
      img = sctx.createImageData(SW, SH);
      pix = img.data;
      heights = new Float32Array(SW * SH);
    }

    window.addEventListener('resize', resize);
    resize();

    // Cheap hash noise (fast)
    function hash2(x, y){
      let n = (x * 374761393 + y * 668265263) | 0;
      n = (n ^ (n >>> 13)) | 0;
      n = (n * 1274126177) | 0;
      return ((n ^ (n >>> 16)) >>> 0) / 4294967296;
    }

    function valueNoise(x, y){
      const xi = Math.floor(x), yi = Math.floor(y);
      const xf = x - xi, yf = y - yi;
      const u = xf * xf * (3 - 2*xf);
      const v = yf * yf * (3 - 2*yf);

      const a = hash2(xi, yi);
      const b = hash2(xi+1, yi);
      const c = hash2(xi, yi+1);
      const d = hash2(xi+1, yi+1);

      const ab = a + (b-a)*u;
      const cd = c + (d-c)*u;
      return (ab + (cd-ab)*v) * 2 - 1; // [-1,1]
    }

    // Height field: 3 directional waves + 1 ripple noise layer
    function waveHeight(x, y, t, p){
      const wind = p.wind;
      const amp = 0.35 + 1.15 * p.height;
      const speed = 0.45 + 1.35 * wind;

      const theta = -0.55 + wind * 0.95;
      const dx0 = Math.cos(theta), dy0 = Math.sin(theta);

      let h = 0;

      // Fewer components for speed
      const c0f=0.70, c0a=1.00;
      const c1f=1.20, c1a=0.45;
      const c2f=1.90, c2a=0.25;

      // Component 0
      let ph = (x*dx0 + y*dy0) * c0f + t * (0.95*c0f) * speed;
      let s = Math.sin(ph);
      h += (s + 0.28*s*s*s) * c0a;

      // Component 1
      const th1 = theta + 0.85;
      ph = (x*Math.cos(th1) + y*Math.sin(th1)) * c1f + t * (1.05*c1f) * speed;
      s = Math.sin(ph);
      h += (s + 0.22*s*s*s) * c1a;

      // Component 2
      const th2 = theta - 1.10;
      ph = (x*Math.cos(th2) + y*Math.sin(th2)) * c2f + t * (1.15*c2f) * speed;
      s = Math.sin(ph);
      h += (s + 0.18*s*s*s) * c2a;

      // Ripples: advected value noise
      const nx = x*0.55 + t*0.55*speed;
      const ny = y*0.55 - t*0.48*speed;
      h += (0.18 + 0.30*wind) * valueNoise(nx, ny);

      return (h * 0.22) * amp;
    }

    function clamp01(v){ return v < 0 ? 0 : (v > 1 ? 1 : v); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    const deep = [0.02, 0.15, 0.23];
    const mid  = [0.03, 0.22, 0.30];
    const crest= [0.10, 0.42, 0.48];

    function lightDir(p){
      const a = lerp(-0.35, 0.55, p.light);
      const elev = lerp(0.50, 0.75, p.light);
      const lx = Math.cos(a), ly = Math.sin(a), lz = elev;
      const inv = 1/Math.hypot(lx,ly,lz);
      return [lx*inv, ly*inv, lz*inv];
    }

    let t0 = performance.now();
    let simT = 0;

    function frame(now){
      const dt = Math.min(0.033, (now - t0) / 1000);
      t0 = now;
      if(!params.paused) simT += dt;

      const L = lightDir(params);
      const V = [0, 0, 1];

      // World scale: larger = broader waves
      const worldScale = lerp(2.2, 1.6, params.wind);

      // PASS 1: heights
      let idx = 0;
      for(let y=0; y<SH; y++){
        const vy = (y/SH - 0.5) * worldScale * (SH/SW);
        for(let x=0; x<SW; x++, idx++){
          const vx = (x/SW - 0.5) * worldScale;
          heights[idx] = waveHeight(vx, vy, simT, params);
        }
      }

      // PASS 2: shading from height buffer
      const invDx = SW / worldScale;
      const invDy = SH / (worldScale * (SH/SW));
      const epsx = 1 / invDx;
      const epsy = 1 / invDy;

      let p = 0;
      for(let y=0; y<SH; y++){
        const y0 = y === 0 ? 0 : y-1;
        const y1 = y === SH-1 ? SH-1 : y+1;
        for(let x=0; x<SW; x++){
          const x0 = x === 0 ? 0 : x-1;
          const x1 = x === SW-1 ? SW-1 : x+1;

          const i  = y*SW + x;
          const hx = (heights[y*SW + x1] - heights[y*SW + x0]) / (2*epsx);
          const hy = (heights[y1*SW + x] - heights[y0*SW + x]) / (2*epsy);

          let nx = -hx, ny = -hy, nz = 1;
          const nInv = 1/Math.hypot(nx, ny, nz);
          nx *= nInv; ny *= nInv; nz *= nInv;

          const ndotl = clamp01(nx*L[0] + ny*L[1] + nz*L[2]);
          const diffuse = 0.18 + 0.72 * ndotl;

          const ndotv = clamp01(nz);
          const fresnel = Math.pow(1 - ndotv, 2.2);

          const hxv = L[0] + V[0], hyv = L[1] + V[1], hzv = L[2] + V[2];
          const hInv = 1/Math.hypot(hxv, hyv, hzv);
          const Hx = hxv*hInv, Hy = hyv*hInv, Hz = hzv*hInv;
          const ndoth = clamp01(nx*Hx + ny*Hy + nz*Hz);
          const shininess = lerp(55, 95, params.light);
          const spec = Math.pow(ndoth, shininess) * lerp(0.18, 0.55, params.light);

          const slope = clamp01((1 - nz) * 2.2);
          const foam = clamp01(0.10 + 0.55*slope);

          const h = heights[i];
          const hMix = clamp01(0.5 + h*3.0);
          let r = lerp(deep[0], mid[0], hMix);
          let g = lerp(deep[1], mid[1], hMix);
          let b = lerp(deep[2], mid[2], hMix);

          r *= diffuse; g *= diffuse; b *= diffuse;

          r = lerp(r, 0.10, fresnel*0.35);
          g = lerp(g, 0.22, fresnel*0.35);
          b = lerp(b, 0.30, fresnel*0.35);

          r = lerp(r, crest[0], foam*0.35);
          g = lerp(g, crest[1], foam*0.35);
          b = lerp(b, crest[2], foam*0.35);

          r += spec; g += spec; b += spec;

          const ux = (x/SW - 0.5);
          const uy = (y/SH - 0.5);
          const vv = clamp01(1 - (ux*ux + uy*uy)*1.1);
          r *= (0.72 + 0.28*vv);
          g *= (0.72 + 0.28*vv);
          b *= (0.72 + 0.28*vv);

          pix[p++] = r<=0 ? 0 : (r>=1 ? 255 : (r*255)|0);
          pix[p++] = g<=0 ? 0 : (g>=1 ? 255 : (g*255)|0);
          pix[p++] = b<=0 ? 0 : (b>=1 ? 255 : (b*255)|0);
          pix[p++] = 255;
        }
      }

      sctx.putImageData(img, 0, 0);

      ctx.imageSmoothingEnabled = true;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.drawImage(sim, 0, 0, W, H);

      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);

    window.addEventListener('keydown', (e)=>{
      if(e.code === 'Space'){ params.paused = !params.paused; e.preventDefault(); }
    });
  </script>
</body>
</html>